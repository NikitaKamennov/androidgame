<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Танчики — демо</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { margin:0; height:100%; background:#0a0e14; color:#e8ecff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #game { display:block; width:100vw; height:100vh; touch-action:none; background: #0c1018; }
    .overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.45); z-index: 10; padding: 20px;
    }
    .overlay.open { display: flex; }
    .panel {
      background: rgba(18,22,35,0.95);
      border: 1px solid #1e2a4f;
      border-radius: 12px;
      padding: 16px;
      max-width: 90vw;
      color: #dfe6ff;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      text-align: center;
    }
    .panel h3 { margin: 0 0 8px; }
    .panel p { margin: 6px 0; color: #9fb3ff; }
    .panel .btn {
      display: inline-grid; place-items: center; padding: 10px 14px; margin-top: 10px;
      border-radius: 10px; border: 1px solid #2a3a6c;
      background: linear-gradient(135deg, #7c9fff, #00d4ff); color: #001221; font-weight: 700; cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="help" class="overlay open">
    <div class="panel">
      <h3>Танчики — демо</h3>
      <p>Цель: защитить свой штаб (орёл) и уничтожить врага или его штаб.</p>
      <p>Управление: стрелки/WSAD — движение, Space — огонь. На телефоне — кнопки на экране.</p>
      <button id="btnStart" class="btn">Старт</button>
    </div>
  </div>

  <div id="modal" class="overlay">
    <div class="panel">
      <h3 id="modalTitle">Сообщение</h3>
      <p id="modalText"></p>
      <button id="btnOk" class="btn">ОК</button>
    </div>
  </div>

  <script>
    // ---------- Константы ----------
    const GRID = 13;                // 13×13 тайлов
    const TILE_EMPTY = 0;
    const TILE_BRICK = 1;
    const TILE_STEEL = 2;
    const TILE_BASE  = 3;           // база игрока (нижняя)
    const TILE_BASE_ENEMY = 4;      // база врага (верхняя)

    const DIR_UP=0, DIR_RIGHT=1, DIR_DOWN=2, DIR_LEFT=3;
    const DIRS = [
      {x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}
    ];

    const FIXED_DT = 1/60;
    const PLAYER_SPEED = 3.2;   // тайл/с
    const ENEMY_SPEED  = 1.6;   // тайл/с
    const BULLET_SPEED = 8.0;   // тайл/с
    const TANK_SIZE = 0.9;      // доля тайла (размер корпуса)
    const RELOAD_TIME = 0.55;   // сек на перезарядку
    const ENEMY_SHOOT_CD = [1.2, 2.2]; // разброс между выстрелами
    const AI_TURN_PROB = 0.015; // шанс случайного поворота/тик

    const COLORS = {
      bg: '#0c1018',
      grid: 'rgba(255,255,255,0.05)',
      brick: '#b5523b',
      steel: '#8f9bb3',
      tankPlayer: '#76e3ff',
      tankEnemy: '#ffd26f',
      bullet: '#fff',
      base: '#eaeaea',
      baseEnemy: '#ffd3d3',
      baseEye: '#222',
      text: '#dfe6ff',
      control: 'rgba(124,159,255,0.2)',
      controlLine: 'rgba(124,159,255,0.9)'
    };

    // ---------- Canvas / адаптив ----------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let view = {
      w: window.innerWidth,
      h: window.innerHeight,
      tile: 24,      // px/тайл (пересчитывается)
      boardSize: 0,  // GRID * tile
      boardX: 0,     // смещение для центрирования
      boardY: 0,
      portrait: false,
      dpad: null,    // геометрия зоны D‑pad
      fire: null     // геометрия кнопки Fire
    };

    function resize(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      view.w = canvas.width;
      view.h = canvas.height;
      view.portrait = view.h >= view.w;

      // Резерв под контролы (внутри канваса)
      const ctrlH = view.portrait ? Math.floor(view.h * 0.30) : Math.floor(view.h * 0.22);

      // Размер доски (квадрат) — уместить с учётом контролов
      const usableH = Math.max(1, view.h - ctrlH);
      const boardPx = Math.min(view.w, usableH);
      view.tile = Math.floor(boardPx / GRID);
      view.boardSize = view.tile * GRID;
      view.boardX = Math.floor((view.w - view.boardSize) / 2);
      view.boardY = Math.floor((usableH - view.boardSize) / 2);

      // Геометрия D‑pad и Fire (px)
      const margin = Math.floor(view.tile * 0.5);
      const padSize = Math.floor(Math.min(view.w, view.h) * 0.28);
      const padR = Math.floor(padSize / 2);

      const dpadY = view.h - padSize - margin;
      view.dpad = {
        x: margin, y: dpadY, w: padSize, h: padSize,
        cx: margin + padR, cy: dpadY + padR, r: padR
      };

      const fireSize = Math.floor(padSize * 0.8);
      const fireR = Math.floor(fireSize / 2);
      const fireX = view.w - fireSize - margin;
      const fireY = view.h - fireSize - margin;
      view.fire = { x: fireX, y: fireY, w: fireSize, h: fireSize, cx: fireX + fireR, cy: fireY + fireR, r: fireR };
    }
    window.addEventListener('resize', ()=> { resize(); draw(); });

    // ---------- Уровень (13×13) ----------
    const level1 = (()=> {
      const map = Array.from({length: GRID}, ()=> Array(GRID).fill(TILE_EMPTY));

      // Стальные стены по периметру
      for (let i=0;i<GRID;i++){
        map[0][i] = TILE_STEEL;
        map[GRID-1][i] = TILE_STEEL;
        map[i][0] = TILE_STEEL;
        map[i][GRID-1] = TILE_STEEL;
      }

      // Несколько стен кирпича и стали
      for (let x=2; x<GRID-2; x+=2) {
        if (x===6) continue; // проход по центру
        map[4][x] = TILE_BRICK;
        map[5][x] = TILE_BRICK;
        map[7][x] = TILE_STEEL;
      }
      // Простой блок лабиринта
      for (let y=2; y<=9; y+=2) {
        map[y][3] = TILE_BRICK;
        map[y][9] = TILE_BRICK;
      }

      // Штаб игрока на (6,12)
      const bx = 6, by = 12;
      map[by][bx] = TILE_BASE;

      // Кирпичи вокруг штаба игрока
      const aroundPlayer = [
        [bx-1, by], [bx+1, by],
        [bx-1, by-1], [bx, by-1], [bx+1, by-1],
        [bx-1, by-2], [bx, by-2], [bx+1, by-2]
      ];
      for (const [x,y] of aroundPlayer) {
        if (y>0 && y<GRID-1 && x>0 && x<GRID-1) map[y][x] = TILE_BRICK;
      }

      // Штаб врага на (6,1)
      const exb = 6, eyb = 1;
      map[eyb][exb] = TILE_BASE_ENEMY;

      const aroundEnemy = [
  [exb-1, eyb], [exb+1, eyb],
  [exb-1, eyb+1], /* [exb, eyb+1] пропускаем */ [exb+1, eyb+1],
  [exb-1, eyb+2], [exb, eyb+2], [exb+1, eyb+2]
];
for (const [x,y] of aroundEnemy) {
  if (y>0 && y<GRID-1 && x>0 && x<GRID-1) map[y][x] = TILE_BRICK;
}

      // Стартовые позиции
      const playerStart = { x: 2, y: GRID-3, dir: DIR_UP };
      const enemyStart  = { x: 6, y: 2, dir: DIR_DOWN }; // не конфликтует с базой врага

      return { map, playerStart, enemyStart, base: {x:6, y:12}, baseEnemy: {x:6, y:1} };
    })();

    // ---------- Игровое состояние ----------
    const State = {
      map: level1.map.map(row => row.slice()),
      baseAlive: true,
      baseEnemyAlive: true,
      player: null,
      enemy: null,
      bullets: [],
      running: false,
      lastTs: 0,
      accum: 0,
      message: '',
      time: 0
    };

    function resetGame(){
      State.map = level1.map.map(row => row.slice());
      State.baseAlive = true;
      State.baseEnemyAlive = true;
      State.bullets = [];
      State.player = makeTank(level1.playerStart.x, level1.playerStart.y, level1.playerStart.dir, true);
      State.enemy  = makeTank(level1.enemyStart.x,  level1.enemyStart.y,  level1.enemyStart.dir,  false);
      State.running = true;
      State.lastTs = 0;
      State.accum = 0;
      State.time = 0;
      closeModal();
    }

    function makeTank(tx, ty, dir, isPlayer){
      return {
        x: tx + 0.5, y: ty + 0.5, dir,
        size: TANK_SIZE, speed: isPlayer ? PLAYER_SPEED : ENEMY_SPEED,
        reload: 0, alive: true, isPlayer,
        nextTurnAt: 0,
        aiShootAt: 0
      };
    }

    // ---------- Утилиты карты / коллизий ----------
    function tileAt(tx, ty){
      if (tx<0 || ty<0 || tx>=GRID || ty>=GRID) return TILE_STEEL; // вне — твёрдо
      return State.map[ty][tx];
    }
    function setTile(tx, ty, v){
      if (tx<0 || ty<0 || tx>=GRID || ty>=GRID) return;
      State.map[ty][tx] = v;
    }
    function aabbSolidCollides(cx, cy, half){
      const minx = cx - half, maxx = cx + half;
      const miny = cy - half, maxy = cy + half;
      const test = [
        {x:minx, y:miny}, {x:maxx, y:miny},
        {x:minx, y:maxy}, {x:maxx, y:maxy}
      ];
      for (const p of test){
        const tx = Math.floor(p.x), ty = Math.floor(p.y);
        const t = tileAt(tx, ty);
        if (t === TILE_BRICK || t === TILE_STEEL || t === TILE_BASE || t === TILE_BASE_ENEMY) return true;
      }
      return false;
    }

    // ---------- Управление ----------
    const Input = { up:false, down:false, left:false, right:false, fire:false };
    document.addEventListener('keydown', (e)=>{
      if (!State.running) return;
      if (e.code==='ArrowUp' || e.code==='KeyW') Input.up=true;
      if (e.code==='ArrowDown' || e.code==='KeyS') Input.down=true;
      if (e.code==='ArrowLeft' || e.code==='KeyA') Input.left=true;
      if (e.code==='ArrowRight' || e.code==='KeyD') Input.right=true;
      if (e.code==='Space') Input.fire=true;
      ensureAudio();
    });
    document.addEventListener('keyup', (e)=>{
      if (e.code==='ArrowUp' || e.code==='KeyW') Input.up=false;
      if (e.code==='ArrowDown' || e.code==='KeyS') Input.down=false;
      if (e.code==='ArrowLeft' || e.code==='KeyA') Input.left=false;
      if (e.code==='ArrowRight' || e.code==='KeyD') Input.right=false;
      if (e.code==='Space') Input.fire=false;
    });

    // Сенсор на канвасе
    const touches = new Map();
    function handleControls(){
      Input.up = Input.down = Input.left = Input.right = false;
      Input.fire = false;

      for (const t of touches.values()){
        // D‑pad
        if (t.x >= view.dpad.x && t.x <= view.dpad.x+view.dpad.w &&
            t.y >= view.dpad.y && t.y <= view.dpad.y+view.dpad.h){
          const dx = t.x - view.dpad.cx;
          const dy = t.y - view.dpad.cy;
          const ax = Math.abs(dx), ay = Math.abs(dy);
          const dead = view.dpad.r * 0.15;
          if (ax > ay){
            if (ax > dead){ Input.left = dx < 0; Input.right = dx > 0; }
          } else {
            if (ay > dead){ Input.up = dy < 0; Input.down = dy > 0; }
          }
        }
        // Fire
        const dfx = t.x - view.fire.cx, dfy = t.y - view.fire.cy;
        const dist2 = dfx*dfx + dfy*dfy;
        if (dist2 <= view.fire.r*view.fire.r) Input.fire = true;
      }
    }
    canvas.addEventListener('touchstart', (e)=> {
      ensureAudio();
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        const pos = { x: t.clientX - rect.left, y: t.clientY - rect.top };
        touches.set(t.identifier, pos);
      }
      handleControls();
    }, {passive:false});
    canvas.addEventListener('touchmove', (e)=> {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        if (touches.has(t.identifier)){
          touches.set(t.identifier, { x: t.clientX - rect.left, y: t.clientY - rect.top });
        }
      }
      handleControls();
    }, {passive:false});
    canvas.addEventListener('touchend', (e)=> {
      e.preventDefault();
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        touches.delete(t.identifier);
      }
      handleControls();
    });
    canvas.addEventListener('touchcancel', (e)=> {
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        touches.delete(t.identifier);
      }
      handleControls();
    });

    // ---------- Логика танков/пуль ----------
    function stepTank(t, dt){
      if (!t.alive) return;

      let moveDir = t.dir;
      let moving = false;

      let wantShoot = false;

if (t.isPlayer){
  if (Input.up)    { moveDir = DIR_UP;    moving = true; }
  else if (Input.down)  { moveDir = DIR_DOWN;  moving = true; }
  else if (Input.left)  { moveDir = DIR_LEFT;  moving = true; }
  else if (Input.right) { moveDir = DIR_RIGHT; moving = true; }
  // Стрелять после обновления направления
  wantShoot = Input.fire;
} else {
  if (State.time >= t.aiShootAt) {
    const px = Math.floor(State.player.x), py = Math.floor(State.player.y);
    const ex = Math.floor(t.x), ey = Math.floor(t.y);
    if (px === ex) moveDir = py < ey ? DIR_UP : DIR_DOWN;
    if (py === ey) moveDir = px < ex ? DIR_LEFT : DIR_RIGHT;
    wantShoot = true;
    t.aiShootAt = State.time + rand(ENEMY_SHOOT_CD[0], ENEMY_SHOOT_CD[1]);
  }
  moving = true;
  if (Math.random() < AI_TURN_PROB) moveDir = Math.floor(Math.random() * 4);
}

// Сначала обновляем направление, потом стреляем
t.dir = moveDir;
if (wantShoot) tryShoot(t);
      t.dir = moveDir;

      if (moving){
        const v = DIRS[t.dir];
        const nx = t.x + v.x * t.speed * dt;
        const ny = t.y + v.y * t.speed * dt;
        const half = t.size * 0.5;

        // X
        if (!aabbSolidCollides(nx, t.y, half)){
          t.x = nx;
        } else if (!t.isPlayer) {
          t.dir = (t.dir + 1 + Math.floor(Math.random()*3)) % 4;
        }
        // Y
        if (!aabbSolidCollides(t.x, ny, half)){
          t.y = ny;
        } else if (!t.isPlayer) {
          t.dir = (t.dir + 2) % 4;
        }
      }

      t.reload = Math.max(0, t.reload - dt);
    }

    function tryShoot(t){
      if (t.reload > 0 || !t.alive) return;
      const activeFromTank = State.bullets.some(b=> b.owner === t);
      if (activeFromTank) return;

      const v = DIRS[t.dir];
      const muzzle = 0.6;
      const bx = t.x + v.x * muzzle;
      const by = t.y + v.y * muzzle;

      State.bullets.push({
        x: bx, y: by, dir: t.dir, speed: BULLET_SPEED, owner: t, alive: true
      });
      t.reload = RELOAD_TIME;
      sfxShoot();
    }

    function stepBullets(dt){
      for (const b of State.bullets){
        if (!b.alive) continue;
        const v = DIRS[b.dir];
        const nx = b.x + v.x * b.speed * dt;
        const ny = b.y + v.y * b.speed * dt;

        const tx = Math.floor(nx), ty = Math.floor(ny);
        const t = tileAt(tx, ty);

        if (t === TILE_STEEL){
          b.alive = false; sfxHit(); continue;
        }
        if (t === TILE_BRICK){
          setTile(tx, ty, TILE_EMPTY);
          b.alive = false; sfxHit(); continue;
        }
       // Запрет дружественного урона по базам
if (t === TILE_BASE){
  if (b.owner && b.owner.isPlayer){
    // Своя пуля в свой штаб — не наносим урон, просто гасим пулю
    b.alive = false; sfxHit(); continue;
  } else {
    // Вражеская пуля — уничтожаем штаб игрока
    State.baseAlive = false;
    b.alive = false;
    sfxExplosion();
    gameOver(false, 'Штаб уничтожен!');
    continue;
  }
}

if (t === TILE_BASE_ENEMY){
  if (b.owner && !b.owner.isPlayer){
    // Своя пуля в свой штаб врага — не наносим урон, просто гасим пулю
    b.alive = false; sfxHit(); continue;
  } else {
    // Пуля игрока — уничтожаем штаб врага
    State.baseEnemyAlive = false;
    b.alive = false;
    sfxExplosion();
    gameOver(true, 'Штаб врага уничтожен! Победа!');
    continue;
  }
}

        // Коллизия с танками
        const target = (b.owner.isPlayer ? State.enemy : State.player);
        if (target.alive){
          const half = target.size * 0.5;
          if (Math.abs(nx - target.x) <= half && Math.abs(ny - target.y) <= half){
            target.alive = false;
            b.alive = false;
            sfxExplosion();
            if (!target.isPlayer) {
              gameOver(true, 'Враг уничтожен! Победа!');
            } else {
              gameOver(false, 'Вы подбиты!');
            }
            continue;
          }
        }

        b.x = nx; b.y = ny;
        if (b.x<0 || b.y<0 || b.x>=GRID || b.y>=GRID) b.alive = false;
      }
      State.bullets = State.bullets.filter(b=> b.alive);
    }

    // ---------- Игровой цикл ----------
    function loop(ts){
      if (!State.running) return;
      if (!State.lastTs) State.lastTs = ts;
      let dt = (ts - State.lastTs) / 1000;
      dt = Math.min(dt, 0.05);
      State.lastTs = ts;
      State.accum += dt;

      while (State.accum >= FIXED_DT){
        stepTank(State.player, FIXED_DT);
        stepTank(State.enemy,  FIXED_DT);
        stepBullets(FIXED_DT);
        State.time += FIXED_DT;
        State.accum -= FIXED_DT;
      }

      draw();
      requestAnimationFrame(loop);
    }

    // ---------- Рендер ----------
    function draw(){
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0,0,canvas.width, canvas.height);

      drawBoard();
      drawControls();
      drawHUD();
    }

    function drawBoard(){
      ctx.save();
      ctx.translate(view.boardX, view.boardY);

      // Поле
      ctx.fillStyle = '#0b0f18';
      ctx.fillRect(0,0,view.boardSize, view.boardSize);

      // Сетка
      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      for(let i=0;i<=GRID;i++){
        const p = i*view.tile;
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(view.boardSize,p); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,view.boardSize); ctx.stroke();
      }

      // Карта
      for (let y=0;y<GRID;y++){
        for (let x=0;x<GRID;x++){
          const t = State.map[y][x];
          const px = x*view.tile, py = y*view.tile;
          if (t === TILE_BRICK){
            ctx.fillStyle = COLORS.brick;
            ctx.fillRect(px, py, view.tile, view.tile);
            ctx.strokeStyle = '#7a3221';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py + view.tile*0.5); ctx.lineTo(px+view.tile, py + view.tile*0.5);
            ctx.moveTo(px + view.tile*0.5, py); ctx.lineTo(px + view.tile*0.5, py+view.tile);
            ctx.stroke();
          } else if (t === TILE_STEEL){
            ctx.fillStyle = COLORS.steel;
            ctx.fillRect(px, py, view.tile, view.tile);
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(px+2, py+2, view.tile-4, 4);
            ctx.fillRect(px+2, py+view.tile-6, view.tile-4, 4);
          } else if (t === TILE_BASE){
            drawBase(px, py, false);
          } else if (t === TILE_BASE_ENEMY){
            drawBase(px, py, true);
          }
        }
      }

      // Танки
      if (State.player.alive) drawTank(State.player, COLORS.tankPlayer);
      if (State.enemy.alive)  drawTank(State.enemy,  COLORS.tankEnemy);

      // Пули
      for (const b of State.bullets){
        const px = b.x * view.tile;
        const py = b.y * view.tile;
        ctx.fillStyle = COLORS.bullet;
        ctx.beginPath();
        ctx.arc(px, py, Math.max(2, view.tile*0.12), 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawBase(px, py, enemy){
      const t = view.tile;
      ctx.fillStyle = enemy ? COLORS.baseEnemy : COLORS.base;
      ctx.fillRect(px, py, t, t);
      // Пиктограмма орла
      ctx.fillStyle = COLORS.baseEye;
      // тело
      ctx.fillRect(px + t*0.2, py + t*0.55, t*0.6, t*0.35);
      // голова
      ctx.fillRect(px + t*0.35, py + t*0.3, t*0.3, t*0.3);
      // клюв
      ctx.fillRect(px + t*0.6, py + t*0.38, t*0.2, t*0.12);
      // крылья
      ctx.fillRect(px + t*0.1, py + t*0.55, t*0.1, t*0.30);
      ctx.fillRect(px + t*0.8, py + t*0.55, t*0.1, t*0.30);
    }

    function drawTank(t, color){
      const px = (t.x * view.tile);
      const py = (t.y * view.tile);
      const sizePx = t.size * view.tile;
      const half = sizePx/2;

      ctx.save();
      // ВАЖНО: тут больше НЕТ translate(view.boardX, view.boardY).
      // Мы уже находимся в системе координат поля (см. drawBoard → translate).
      ctx.translate(px, py);

      const ang = [ -Math.PI/2, 0, Math.PI/2, Math.PI ][t.dir];
      ctx.rotate(ang);

      // Корпус
      ctx.fillStyle = color;
      ctx.strokeStyle = '#000a';
      ctx.lineWidth = 2;
      roundRect(ctx, -half, -half, sizePx, sizePx, Math.max(2, sizePx*0.12), true, true);

      // Гусеницы
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(-half, -half, sizePx, sizePx*0.22);
      ctx.fillRect(-half, half - sizePx*0.22, sizePx, sizePx*0.22);

      // Башня
      const turretR = sizePx*0.20;
      ctx.beginPath(); ctx.arc(0, 0, turretR, 0, Math.PI*2); ctx.fillStyle = '#0008'; ctx.fill();

      // Ствол
      ctx.fillStyle = '#eaf2ff';
      ctx.fillRect(-sizePx*0.05, -sizePx*0.5, sizePx*0.10, sizePx*0.32);

      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, Math.abs(w)/2, Math.abs(h)/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawControls(){
      // D‑pad
      ctx.save();
      ctx.beginPath();
      ctx.arc(view.dpad.cx, view.dpad.cy, view.dpad.r, 0, Math.PI*2);
      ctx.fillStyle = COLORS.control; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = COLORS.controlLine; ctx.stroke();

      // Крест
      ctx.strokeStyle = COLORS.controlLine;
      ctx.lineWidth = 3;
      arrow(view.dpad.cx, view.dpad.cy - view.dpad.r*0.55, 0);
      arrow(view.dpad.cx + view.dpad.r*0.55, view.dpad.cy, Math.PI/2);
      arrow(view.dpad.cx, view.dpad.cy + view.dpad.r*0.55, Math.PI);
      arrow(view.dpad.cx - view.dpad.r*0.55, view.dpad.cy, -Math.PI/2);

      // Fire
      ctx.beginPath();
      ctx.arc(view.fire.cx, view.fire.cy, view.fire.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,120,120,0.18)'; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,120,120,0.9)'; ctx.stroke();

      ctx.fillStyle = 'rgba(255,200,200,0.9)';
      ctx.font = `${Math.max(12, Math.floor(view.fire.r*0.5))}px system-ui, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('FIRE', view.fire.cx, view.fire.cy);
      ctx.restore();

      function arrow(x, y, rot){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);
        const len = view.dpad.r * 0.35;
        ctx.beginPath();
        ctx.moveTo(0, -len*0.6);
        ctx.lineTo(0, len*0.6);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -len*0.75);
        ctx.lineTo(-len*0.2, -len*0.35);
        ctx.lineTo(len*0.2, -len*0.35);
        ctx.closePath();
        ctx.fillStyle = COLORS.controlLine;
        ctx.fill();
        ctx.restore();
      }
    }

    function drawHUD(){
      const pad = 10;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(pad, pad, Math.min(view.w - 2*pad, 360), 38);

      ctx.fillStyle = COLORS.text;
      ctx.font = '14px system-ui, sans-serif';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      ctx.fillText(
        `Ваш штаб: ${State.baseAlive ? 'цел' : 'уничтожен'}   Штаб врага: ${State.baseEnemyAlive ? 'цел' : 'уничтожен'}   Враг: ${State.enemy.alive ? 'жив' : 'поражён'}`,
        pad + 8, pad + 19
      );

      if (!State.running){
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,view.w, view.h);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px system-ui, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(State.message || 'Игра окончена', view.w/2, view.h/2);
        ctx.font = '14px system-ui, sans-serif';
        ctx.fillText('Нажмите Старт, чтобы сыграть снова', view.w/2, view.h/2 + 26);
      }
    }

    // ---------- Завершение игры / модалка ----------
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modalTitle');
    const modalText = document.getElementById('modalText');
    const btnOk = document.getElementById('btnOk');

    function openModal(title, text){
      modalTitle.textContent = title;
      modalText.textContent = text;
      modal.classList.add('open');
    }
    function closeModal(){ modal.classList.remove('open'); }

    function gameOver(win, text){
      State.running = false;
      State.message = text;
      openModal(win ? 'Победа!' : 'Поражение', text);
      musicStop();
    }
    btnOk.addEventListener('click', ()=>{
      closeModal();
      document.getElementById('help').classList.add('open');
    });

    // ---------- Аудио: Web Audio API ----------
    let actx = null;
    let musicNode = null;
    let musicTimer = null;

    function ensureAudio(){
      if (!actx){
        actx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function sfxShoot(){
      if (!actx) return;
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.type = 'square';
      osc.frequency.value = 680;
      const now = actx.currentTime;
      gain.gain.setValueAtTime(0.0, now);
      gain.gain.linearRampToValueAtTime(0.25, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
      osc.frequency.exponentialRampToValueAtTime(300, now + 0.12);
      osc.connect(gain).connect(actx.destination);
      osc.start(now);
      osc.stop(now + 0.13);
    }
    function sfxHit(){
      if (!actx) return;
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.type = 'triangle';
      const now = actx.currentTime;
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.exponentialRampToValueAtTime(60, now + 0.18);
      gain.gain.setValueAtTime(0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      osc.connect(gain).connect(actx.destination);
      osc.start(now); osc.stop(now + 0.2);
    }
    function sfxExplosion(){
      if (!actx) return;
      const noise = actx.createBufferSource();
      const buffer = actx.createBuffer(1, actx.sampleRate * 0.3, actx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); }
      noise.buffer = buffer;
      const filter = actx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1200;
      const gain = actx.createGain();
      const now = actx.currentTime;
      gain.gain.setValueAtTime(0.6, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);
      noise.connect(filter).connect(gain).connect(actx.destination);
      noise.start(now); noise.stop(now + 0.33);
    }

    // Простая чиптюн‑мелодия (в стиле 8‑бит), зацикленная
    const melody = [
      { f: 392.00, d: 0.25 }, // G4
      { f: 523.25, d: 0.25 }, // C5
      { f: 587.33, d: 0.25 }, // D5
      { f: 523.25, d: 0.25 }, // C5
      { f: 659.25, d: 0.25 }, // E5
      { f: 587.33, d: 0.25 }, // D5
      { f: 523.25, d: 0.25 }, // C5
      { f: 392.00, d: 0.50 }, // G4
      { f: 0, d: 0.12 },      // пауза
      { f: 392.00, d: 0.25 }, // G4
      { f: 440.00, d: 0.25 }, // A4
      { f: 523.25, d: 0.25 }, // C5
      { f: 587.33, d: 0.25 }, // D5
      { f: 659.25, d: 0.25 }, // E5
      { f: 587.33, d: 0.25 }, // D5
      { f: 523.25, d: 0.50 }, // C5
      { f: 0, d: 0.25 }
    ];
    function musicStart(){
      if (!actx) return;
      musicStop();
      const gain = actx.createGain();
      gain.gain.value = 0.12;
      gain.connect(actx.destination);

      const osc = actx.createOscillator();
      osc.type = 'square';
      osc.connect(gain);
      musicNode = { osc, gain };

      osc.start();
      let idx = 0;
      musicTimer = setInterval(()=>{
        const n = melody[idx];
        if (!musicNode) return;
        if (n.f > 0) {
          musicNode.osc.frequency.setValueAtTime(n.f, actx.currentTime);
          musicNode.gain.gain.setTargetAtTime(0.12, actx.currentTime, 0.02);
        } else {
          musicNode.gain.gain.setTargetAtTime(0.001, actx.currentTime, 0.02);
        }
        idx = (idx + 1) % melody.length;
      }, 400);
    }
    function musicStop(){
      if (musicTimer){ clearInterval(musicTimer); musicTimer = null; }
      if (musicNode){
        try { musicNode.osc.stop(); } catch {}
        try { musicNode.gain.disconnect(); } catch {}
        musicNode = null;
      }
    }

    // ---------- Вспомогательное ----------
    function rand(a,b){ return a + Math.random()*(b-a); }

    // ---------- Старт / UI ----------
    const help = document.getElementById('help');
    document.getElementById('btnStart').addEventListener('click', ()=>{
      ensureAudio();
      musicStart();
      help.classList.remove('open');
      resetGame();
      resize();
      requestAnimationFrame(loop);
    });



    // ---------- Запуск ----------
    resize();
    draw();

  </script>
</body>
</html>